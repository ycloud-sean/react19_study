<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Day 5&colon; JSX&#x57fa;&#x7840; &lpar;JSX Fundamentals&rpar;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="day-5-jsx基础-jsx-fundamentals">Day 5: JSX基础 (JSX Fundamentals)</h1>
<h2 id="今日学习-todays-learning">今日学习 (Today's Learning)</h2>
<ul>
<li><strong>核心概念</strong>: createElement函数、React Element对象结构、JSX转换机制</li>
<li><strong>重点文件</strong>:
<ul>
<li><code>packages/react/src/jsx/ReactJSXElement.js</code> (第1-10行)</li>
<li><code>packages/shared/getComponentNameFromType.js</code> (第58-70行)</li>
</ul>
</li>
<li><strong>学习方式</strong>: 逐行阅读源码</li>
</ul>
<h2 id="源码理解-source-code-understanding">源码理解 (Source Code Understanding)</h2>
<h3 id="文件-reactjsxelementjs">文件: ReactJSXElement.js</h3>
<h4 id="第1-6行-版权声明">第1-6行: 版权声明</h4>
<pre><code class="language-javascript"><span class="hljs-comment">/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */</span>
</code></pre>
<ul>
<li>标准的MIT许可证版权声明</li>
<li>Meta Platforms即Facebook的公司名</li>
</ul>
<h4 id="第8-10行-导入语句">第8-10行: 导入语句</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> getComponentNameFromType <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;shared/getComponentNameFromType&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactSharedInternals</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;shared/ReactSharedInternals&#x27;</span>;
<span class="hljs-keyword">import</span> hasOwnProperty <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;shared/hasOwnProperty&#x27;</span>;
</code></pre>
<ul>
<li><strong>getComponentNameFromType</strong>: 从组件类型获取组件名称的函数</li>
<li><strong>ReactSharedInternals</strong>: React内部共享变量集合</li>
<li><strong>hasOwnProperty</strong>: 安全检查对象属性的封装</li>
</ul>
<h3 id="文件-getcomponentnamefromtypejs">文件: getComponentNameFromType.js</h3>
<h4 id="第58-59行-函数定义">第58-59行: 函数定义</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponentNameFromType</span>(<span class="hljs-params">type: mixed</span>): string | <span class="hljs-literal">null</span>
</code></pre>
<ul>
<li>默认导出函数</li>
<li>参数：<code>type: mixed</code> - 可以是任何类型</li>
<li>返回：<code>string | null</code> - 组件名称或null</li>
</ul>
<h4 id="第60-63行-处理null值">第60-63行: 处理null值</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// Host root, text node or just invalid type.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<ul>
<li>如果type是null或undefined，返回null</li>
<li>Host root: React应用挂载的根节点</li>
<li>不是组件，没有名称</li>
</ul>
<h4 id="第64-70行-处理函数类型">第64-70行: 处理函数类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;function&#x27;</span>) {
  <span class="hljs-keyword">if</span> ((<span class="hljs-attr">type</span>: any).<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_CLIENT_REFERENCE</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">return</span> (<span class="hljs-attr">type</span>: any).<span class="hljs-property">displayName</span> || type.<span class="hljs-property">name</span> || <span class="hljs-literal">null</span>;
}
</code></pre>
<ul>
<li>检查type是否为函数类型</li>
<li>优先级：<code>displayName</code> &gt; <code>name</code> &gt; <code>null</code></li>
<li>React 19新特性：Client Reference特殊标记</li>
<li>目前返回null（TODO：未来添加命名约定）</li>
</ul>
<h4 id="第71-73行-处理字符串类型">第71-73行: 处理字符串类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;string&#x27;</span>) {
  <span class="hljs-keyword">return</span> type;
}
</code></pre>
<ul>
<li>如果type是字符串（如'div', 'span'）</li>
<li>直接返回字符串本身</li>
</ul>
<h4 id="第74-86行-switch语句---react特殊类型">第74-86行: Switch语句 - React特殊类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">switch</span> (type) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FRAGMENT_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Fragment&#x27;</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROFILER_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Profiler&#x27;</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_STRICT_MODE_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;StrictMode&#x27;</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Suspense&#x27;</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_LIST_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;SuspenseList&#x27;</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ACTIVITY_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Activity&#x27;</span>;
}
</code></pre>
<ul>
<li>检查React内置组件类型</li>
<li>直接返回对应的字符串名称</li>
</ul>
<h4 id="第87-96行-条件性返回viewtransition和tracingmarker">第87-96行: 条件性返回（ViewTransition和TracingMarker）</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_VIEW_TRANSITION_TYPE</span>:
  <span class="hljs-keyword">if</span> (enableViewTransition) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ViewTransition&#x27;</span>;
  }
<span class="hljs-comment">// Fall through</span>
<span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_TRACING_MARKER_TYPE</span>:
  <span class="hljs-keyword">if</span> (enableTransitionTracing) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;TracingMarker&#x27;</span>;
  }
}
</code></pre>
<ul>
<li>使用特性标志（Feature Flags）控制新特性</li>
<li><code>fall through</code>故意穿透机制</li>
<li>未启用时跳过处理</li>
</ul>
<h4 id="第97-105行-处理对象类型和错误检查">第97-105行: 处理对象类型和错误检查</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;object&#x27;</span>) {
  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (<span class="hljs-attr">type</span>: any).<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;number&#x27;</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">&#x27;Received an unexpected object in getComponentNameFromType(). &#x27;</span> +
          <span class="hljs-string">&#x27;This is likely a bug in React. Please file an issue.&#x27;</span>,
      );
    }
  }
</code></pre>
<ul>
<li>检查type是否为对象类型</li>
<li>开发环境错误检查机制</li>
<li>检测异常情况并提示用户</li>
</ul>
<h4 id="第106-108行-portal类型">第106-108行: Portal类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">switch</span> (type.<span class="hljs-property">$$typeof</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Portal&#x27;</span>;
</code></pre>
<ul>
<li>检查对象的<code>$$typeof</code>属性</li>
<li>使用Symbol标识React对象类型</li>
<li>Portal: 用于DOM不同位置渲染</li>
</ul>
<h4 id="第109-115行-provider类型">第109-115行: Provider类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROVIDER_TYPE</span>:
  <span class="hljs-keyword">if</span> (enableRenderableContext) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> provider = (<span class="hljs-attr">type</span>: any);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(provider.<span class="hljs-property">_context</span>) + <span class="hljs-string">&#x27;.Provider&#x27;</span>;
  }
</code></pre>
<ul>
<li>Context的Provider对象</li>
<li>根据特性标志决定返回逻辑</li>
<li>拼接<code>.Provider</code>后缀</li>
</ul>
<h4 id="第116-122行-context类型">第116-122行: Context类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_CONTEXT_TYPE</span>:
  <span class="hljs-keyword">const</span> <span class="hljs-attr">context</span>: <span class="hljs-title class_">ReactContext</span>&lt;any&gt; = (<span class="hljs-attr">type</span>: any);
  <span class="hljs-keyword">if</span> (enableRenderableContext) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(context) + <span class="hljs-string">&#x27;.Provider&#x27;</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(context) + <span class="hljs-string">&#x27;.Consumer&#x27;</span>;
  }
</code></pre>
<ul>
<li>Context基本对象类型</li>
<li>根据特性标志返回Provider或Consumer</li>
</ul>
<h4 id="第123-129行-consumer类型">第123-129行: Consumer类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_CONSUMER_TYPE</span>:
  <span class="hljs-keyword">if</span> (enableRenderableContext) {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">consumer</span>: <span class="hljs-title class_">ReactConsumerType</span>&lt;any&gt; = (<span class="hljs-attr">type</span>: any);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(consumer.<span class="hljs-property">_context</span>) + <span class="hljs-string">&#x27;.Consumer&#x27;</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
</code></pre>
<ul>
<li>Context的Consumer对象</li>
<li><code>_context</code>: 获取对应Context对象的内部属性</li>
</ul>
<h4 id="第130-131行-forwardref类型">第130-131行: ForwardRef类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FORWARD_REF_TYPE</span>:
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getWrappedName</span>(type, type.<span class="hljs-property">render</span>, <span class="hljs-string">&#x27;ForwardRef&#x27;</span>);
</code></pre>
<ul>
<li>forwardRef创建的组件类型</li>
<li>调用getWrappedName函数处理</li>
</ul>
<h4 id="第132-137行-memo类型">第132-137行: Memo类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_MEMO_TYPE</span>:
  <span class="hljs-keyword">const</span> outerName = (<span class="hljs-attr">type</span>: any).<span class="hljs-property">displayName</span> || <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (outerName !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> outerName;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentNameFromType</span>(type.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Memo&#x27;</span>;
</code></pre>
<ul>
<li>memo创建的组件类型</li>
<li>优先级：外部displayName &gt; 内部类型名称 &gt; 默认'Memo'</li>
</ul>
<h4 id="第138-147行-lazy类型">第138-147行: Lazy类型</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>: {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">lazyComponent</span>: <span class="hljs-title class_">LazyComponent</span>&lt;any, any&gt; = (<span class="hljs-attr">type</span>: any);
  <span class="hljs-keyword">const</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
  <span class="hljs-keyword">const</span> init = lazyComponent.<span class="hljs-property">_init</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentNameFromType</span>(<span class="hljs-title function_">init</span>(payload));
  } <span class="hljs-keyword">catch</span> (x) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</code></pre>
<ul>
<li>lazy创建的组件类型</li>
<li>动态初始化机制</li>
<li>异常处理确保稳定性</li>
</ul>
<h4 id="第148-151行-函数结尾">第148-151行: 函数结尾</h4>
<pre><code class="language-javascript">    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<ul>
<li>闭合对象switch语句和条件判断</li>
<li>默认返回null（处理未知类型）</li>
</ul>
<hr>
<h2 id="今天学习总结">今天学习总结</h2>
<h3 id="完成内容">完成内容</h3>
<ol>
<li>✅ ReactJSXElement.js文件头部（第1-10行）</li>
<li>✅ getComponentNameFromType函数完整实现（第58-151行）</li>
<li>✅ 深入理解各种组件类型的名称获取机制</li>
</ol>
<h3 id="核心概念">核心概念</h3>
<ul>
<li><strong>组件类型分类</strong>: null、函数、字符串、对象</li>
<li><strong>React特殊类型</strong>: Fragment、Profiler、Suspense等</li>
<li><strong>对象包装类型</strong>: Portal、Context、ForwardRef、Memo、Lazy</li>
<li><strong>特性标志机制</strong>: enableViewTransition、enableTransitionTracing等</li>
<li><strong>Client Reference</strong>: React 19新特性</li>
</ul>
<h3 id="明日预告">明日预告</h3>
<ul>
<li>继续阅读ReactJSXElement.js的createElement函数实现</li>
<li>学习key和ref的详细处理逻辑</li>
<li>理解props解析和children处理机制</li>
</ul>
<hr>
<p><strong>学习状态</strong>: 进行中
<strong>完成进度</strong>: 基础概念理解阶段
<strong>下一步</strong>: createElement函数深入学习</p>
<h4 id="函数签名">函数签名</h4>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, config, children</span>)
</code></pre>
<h4 id="参数详解">参数详解</h4>
<ol>
<li>
<p><strong>type</strong> - 元素类型</p>
<ul>
<li>字符串 ('div', 'span')：DOM元素</li>
<li>函数：函数组件</li>
<li>类：类组件</li>
</ul>
</li>
<li>
<p><strong>config</strong> - 配置对象 (可选)</p>
<ul>
<li>包含元素的属性和配置</li>
<li>保留属性：<code>key</code>, <code>ref</code></li>
<li>过滤属性：<code>__self</code>, <code>__source</code></li>
</ul>
</li>
<li>
<p><strong>children</strong> - 子元素 (可选)</p>
<ul>
<li>可以是字符串、数字、React Element或数组</li>
<li>支持多个参数 (variadic arguments)</li>
</ul>
</li>
</ol>
<h4 id="核心处理逻辑">核心处理逻辑</h4>
<h5 id="1-验证和预处理-第659-661行">1. 验证和预处理 (第659-661行)</h5>
<pre><code class="language-javascript"><span class="hljs-comment">// Reserved names are extracted</span>
<span class="hljs-keyword">const</span> props = {};
<span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;
</code></pre>
<h5 id="2-提取key-第684-689行">2. 提取key (第684-689行)</h5>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidKey</span>(config)) {
  <span class="hljs-keyword">if</span> (__DEV__) {
    <span class="hljs-title function_">checkKeyStringCoercion</span>(config.<span class="hljs-property">key</span>);
  }
  key = <span class="hljs-string">&#x27;&#x27;</span> + config.<span class="hljs-property">key</span>;
}
</code></pre>
<ul>
<li>验证key的有效性</li>
<li>转换为字符串类型</li>
</ul>
<h5 id="3-提取props-第692-706行">3. 提取props (第692-706行)</h5>
<pre><code class="language-javascript"><span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) {
  <span class="hljs-keyword">if</span> (
    hasOwnProperty.<span class="hljs-title function_">call</span>(config, propName) &amp;&amp;
    propName !== <span class="hljs-string">&#x27;key&#x27;</span> &amp;&amp;
    propName !== <span class="hljs-string">&#x27;__self&#x27;</span> &amp;&amp;
    propName !== <span class="hljs-string">&#x27;__source&#x27;</span>
  ) {
    props[propName] = config[propName];
  }
}
</code></pre>
<ul>
<li>过滤保留属性</li>
<li>复制其余属性到props</li>
</ul>
<h5 id="4-处理children-第711-725行">4. 处理children (第711-725行)</h5>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> childrenLength = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>;
<span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) {
  props.<span class="hljs-property">children</span> = children;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">const</span> childArray = <span class="hljs-title class_">Array</span>(childrenLength);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; childrenLength; i++) {
    childArray[i] = <span class="hljs-variable language_">arguments</span>[i + <span class="hljs-number">2</span>];
  }
  props.<span class="hljs-property">children</span> = childArray;
}
</code></pre>
<ul>
<li>单个child：直接赋值</li>
<li>多个children：创建数组</li>
</ul>
<h5 id="5-默认值处理-第728-735行">5. 默认值处理 (第728-735行)</h5>
<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (type &amp;&amp; type.<span class="hljs-property">defaultProps</span>) {
  <span class="hljs-keyword">const</span> defaultProps = type.<span class="hljs-property">defaultProps</span>;
  <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> defaultProps) {
    <span class="hljs-keyword">if</span> (props[propName] === <span class="hljs-literal">undefined</span>) {
      props[propName] = defaultProps[propName];
    }
  }
}
</code></pre>
<h5 id="6-返回reactelement-第748-763行">6. 返回ReactElement (第748-763行)</h5>
<pre><code class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactElement</span>(
  type,
  key,
  <span class="hljs-literal">undefined</span>,
  <span class="hljs-literal">undefined</span>,
  <span class="hljs-title function_">getOwner</span>(),
  props,
  __DEV__ &amp;&amp; <span class="hljs-title class_">Error</span>(...),
  __DEV__ &amp;&amp; <span class="hljs-title function_">createTask</span>(...),
);
</code></pre>
<h3 id="2-reactelement构造函数-第176-253行">2. ReactElement构造函数 (第176-253行)</h3>
<h4 id="开发环境版本-第197-239行">开发环境版本 (第197-239行)</h4>
<pre><code class="language-javascript">element = {
  <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span>,  <span class="hljs-comment">// 元素类型标识</span>
  type,                         <span class="hljs-comment">// 元素类型</span>
  key,                          <span class="hljs-comment">// 元素的key</span>
  props,                        <span class="hljs-comment">// 元素属性</span>
  <span class="hljs-attr">_owner</span>: owner,                <span class="hljs-comment">// 所有者组件</span>
};
</code></pre>
<p><strong>特殊属性</strong>：</p>
<ul>
<li><strong>ref</strong> (第217-238行)：通过<code>Object.defineProperty</code>定义，有警告</li>
<li><strong>_store</strong> (第260-271行)：存储验证标记</li>
<li><strong>_debugInfo</strong>：调试信息</li>
<li><strong>_debugStack/_debugTask</strong>：调试堆栈和任务</li>
</ul>
<h4 id="生产环境版本-第242-252行">生产环境版本 (第242-252行)</h4>
<pre><code class="language-javascript">element = {
  <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span>,
  type,
  key,
  ref,                          <span class="hljs-comment">// 普通属性，无警告</span>
  props,
};
</code></pre>
<h3 id="3-element对象结构">3. Element对象结构</h3>
<h4 id="核心属性">核心属性</h4>
<pre><code class="language-javascript">{
  <span class="hljs-attr">$$typeof</span>: <span class="hljs-title class_">Symbol</span>(react.<span class="hljs-property">transitional</span>.<span class="hljs-property">element</span>),  <span class="hljs-comment">// 类型标识</span>
  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,                                  <span class="hljs-comment">// 元素类型</span>
  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;my-key&#x27;</span>,                                <span class="hljs-comment">// 列表标识</span>
  <span class="hljs-attr">ref</span>: <span class="hljs-literal">null</span>,                                    <span class="hljs-comment">// 引用 (开发环境)</span>
  <span class="hljs-attr">props</span>: {                                      <span class="hljs-comment">// 元素属性</span>
    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;test&#x27;</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>
  },
  <span class="hljs-comment">// 开发环境特有</span>
  <span class="hljs-attr">_owner</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">_store</span>: { <span class="hljs-attr">validated</span>: <span class="hljs-number">0</span> }
}
</code></pre>
<h2 id="实践验证-practical-verification">实践验证 (Practical Verification)</h2>
<h3 id="测试结果">测试结果</h3>
<pre><code class="language-bash"><span class="hljs-comment"># 运行createElement测试</span>
yarn <span class="hljs-built_in">test</span> -- --testPathPattern=<span class="hljs-string">&quot;createElement&quot;</span> --verbose

<span class="hljs-comment"># 结果: 27个测试全部通过</span>
</code></pre>
<h3 id="实际测试示例">实际测试示例</h3>
<pre><code class="language-javascript"><span class="hljs-comment">// 1. 基本用法</span>
<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, { <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;test&#x27;</span> }, <span class="hljs-string">&#x27;Hello&#x27;</span>)
<span class="hljs-comment">// → { type: &#x27;div&#x27;, props: { className: &#x27;test&#x27;, children: &#x27;Hello&#x27; } }</span>

<span class="hljs-comment">// 2. 带key</span>
<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;my-key&#x27;</span> }, <span class="hljs-string">&#x27;Content&#x27;</span>)
<span class="hljs-comment">// → { type: &#x27;div&#x27;, key: &#x27;my-key&#x27;, props: { children: &#x27;Content&#x27; } }</span>

<span class="hljs-comment">// 3. 多个children</span>
<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;Child1&#x27;</span>, <span class="hljs-string">&#x27;Child2&#x27;</span>, <span class="hljs-string">&#x27;Child3&#x27;</span>)
<span class="hljs-comment">// → { type: &#x27;div&#x27;, props: { children: [&#x27;Child1&#x27;, &#x27;Child2&#x27;, &#x27;Child3&#x27;] } }</span>

<span class="hljs-comment">// 4. 嵌套元素</span>
<span class="hljs-keyword">const</span> child = <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;Child&#x27;</span>);
<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, child);
<span class="hljs-comment">// → { type: &#x27;div&#x27;, props: { children: { type: &#x27;span&#x27;, props: {...} } } }</span>
</code></pre>
<h2 id="关键概念-key-concepts">关键概念 (Key Concepts)</h2>
<h3 id="1-jsx转换">1. JSX转换</h3>
<pre><code class="language-javascript"><span class="hljs-comment">// JSX语法</span>
&lt;div className=<span class="hljs-string">&quot;test&quot;</span>&gt;<span class="hljs-title class_">Hello</span>&lt;/div&gt;

<span class="hljs-comment">// 转换为</span>
<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, { <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;test&#x27;</span> }, <span class="hljs-string">&#x27;Hello&#x27;</span>)

<span class="hljs-comment">// 转换为React Element对象</span>
{
  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,
  <span class="hljs-attr">props</span>: { <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> }
}
</code></pre>
<h3 id="2-element-vs-component">2. Element vs Component</h3>
<ul>
<li><strong>Element</strong>: 描述你在屏幕上看到的内容 (immutable)</li>
<li><strong>Component</strong>: 描述如何生成Element (可以是有状态或无状态的函数)</li>
</ul>
<h3 id="3-key的作用">3. key的作用</h3>
<ul>
<li>帮助React识别哪些元素改变了</li>
<li>只在列表渲染时需要</li>
<li>应该是稳定、唯一、可预测的</li>
</ul>
<h3 id="4-ref的变化">4. ref的变化</h3>
<ul>
<li><strong>React 19之前</strong>: <code>element.ref</code>是特殊属性</li>
<li><strong>React 19</strong>: <code>ref</code>变成普通prop，会从element对象移除</li>
</ul>
<h2 id="疑问点-questions">疑问点 (Questions)</h2>
<ul>
<li>JSX转换如何处理静态类型？</li>
<li>为什么children有特殊处理逻辑？</li>
<li>React如何利用$$typeof区分Element？</li>
</ul>
<h2 id="明日任务-tomorrows-tasks">明日任务 (Tomorrow's Tasks)</h2>
<ul>
<li>Day 6: createElement实现深入</li>
<li>学习key和ref的详细处理</li>
<li>理解props的解析机制</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>